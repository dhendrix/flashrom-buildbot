#!/bin/bash -x
# TODO: Handle tarballs later.

. buildbot.conf

# remembers the VMs that were already running
declare -A vms_were_running

# stores a mapping of vbox VM names and their IP addresses
declare -A vbox_ips

fill_vbox_ips() {
	for ck in "${!compilers[@]}"; do
		local vmname=${vbox_names[$ck]}
		[ -z $vmname ] && continue
		local hostonlyif=$(vboxmanage showvminfo ${vmname} --machinereadable | grep -oP '(?<=hostonlyadapter2=")[^"]+')
		local vmip=$(VBoxManage list hostonlyifs | grep -ozP "(?s)Name: +${hostonlyif}.*?IPAddress:\N*" | grep -ozP "(?<=IPAddress:       )[0-9.]+")
		vmip=${vmip%.1}.2
		if ! valid_ip "$vmip" ; then
			msg_err "Could not retrieve IP for $ck correctly (got $vmip)"
		fi
		vbox_ips["$ck"]=$vmip
	done
}

# This code is based on one from Linux Journal June 26, 2008 
valid_ip() {
	local ip=$1

	# Check the IP address under test to see if it matches the extended REGEX
	regex="^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$"
	if [[ ! $ip =~ $regex ]] ; then
		return 1
	fi
	oifs=$IFS
	IFS='.'
	for num in $ip ; do
		if [ $num -gt 255 ]; then
			IFS=$oifs
			return 1
		fi
	done
	IFS=$oifs
	return 0
}

# checks if parameter is an element in an array. invocation example: is_in "gcc" "${available_compilers[@]}"
is_in () {
	arr=$1
	shift
	for elem in "$@"; do
		[[ "$elem" == "$arr" ]] && return 0;
	done
	return 1
}

# checks if parameter is a key in an associative array. invocation example: is_key_in "dos" "$(declare -p available_compilers)"
is_key_in () {
	key="$1"
	eval "local -A arr="${2#*=} # deserialize and eliminate old name/assignment
	test -n "${arr[$key]}"
}

# checks if parameter is element in an associative array and returns the key in the 3rd variable.
# invocation example: get_key_from_name "i586-pc-msdosdjgpp-gcc" "$(declare -p available_compilers)" "ret_val"
get_key_from_name () {
	name="$1"
	eval "local -A arr="${2#*=} # deserialize and eliminate old name/assignment
	for key in "${!arr[@]}"; do
		if [ "${arr["$key"]}" = "$name" ]; then
			eval "$3="$key""
			return 0
		fi
	done
	return 1
}

show_help() {
	echo "Usage:
${0} [-n] [-p/-np] [-s sourcepath] [-j numthreads] [-nc] [-c compiler]... [flashrom build options]

Options
    -h or --help
        Display this message.
    -n or --dry-run
        Do not create any directories or files.
    -p or --private
        do not make results public
    -np or --public
        *do* make results public
    -s or --source
        path to flashrom sources to build
    -c or --compiler
        adds a compiler to the list of compilers to use (replaces the default list, can be given multiple times)
    -j or --threads
        maximum number of concurrent build jobs
    -nc or --no-cleanup
        do not cleanup working directories

    Possible compilers are: ${!available_compilers[@]}"
	exit 1
}

msg_err () {
	echo "$@ Aborting." >&2
	exit 1
}

check_arg () {
	if [ $# -ne 2 -o -z "$2" ] || [[ "$2" == -* ]]; then
		msg_err "Missing argument for $1."
	fi
}

#default values
flashrom_source=.
vm_user="flashrom"
vm_workdir="/tmp/buildbot"
www_root="/home/${vm_user}/public_html/buildbot.flashrom.org"
libs_base="/home/${vm_user}/cross-libs"
declare -A compilers=()
flashrom_opts=()
priv=-1
cleanup=1
dryrun=0
j=2 # default threads

# constants
workdir_base="/tmp"

while [ $# -gt 0 ];
do
	case ${1} in
	-h|--help)
		show_help;
		shift;;
	-n|--dry-run)
		dryrun=1;
		shift;;
	-s|--source)
		check_arg $1 "$2"
		if [ ! -d "$2" ]; then
			msg_err "$2 is not a directory."
		fi
		flashrom_source="$2"
		shift 2;;
	-c|--compiler)
		check_arg $1 "$2"
		key_var=
		if is_key_in "$2" "$(declare -p available_compilers)" ; then
			compilers["$2"]="${available_compilers["$2"]}"
		elif get_key_from_name "$2" "$(declare -p available_compilers)" "key_var"; then
			compilers["$key_var"]="$2"
		else
			msg_err "$2 is not in the list of available compilers (nor their aliases)"
		fi
		shift 2;;
	-p|--private)
		if [ "$priv" -eq 0 ]; then
			msg_err "-p and -np are mutial exclusive."
		fi
		priv=1
		shift;;
	-np|--public)
		if [ "$priv" -eq 1 ]; then
			msg_err "-p and -np are mutial exclusive."
		fi
		priv=0
		shift;;
	-nc|--no-cleanup)
		cleanup=0
		shift;;
	-j|--threads)
		check_arg $1 "$2"
		if [ "$2" -lt 1 ]; then
			msg_err "Less than 1 concurrent process is a bad idea. $2 requested."
		fi
		j="$2"
		shift 2;;
	-*)
		show_help;
		msg_err "invalid option: $1"
		;;
	*)	# everything else are flashrom build parameters
		flashrom_opts+=(" $1")
		shift;;
	esac;
done

if [ "$priv" -eq -1 ]; then
	priv=1
fi

if [ ! -d "${flashrom_source}" -o ! -e "${flashrom_source}/flashrom.c" ]; then
	msg_err "${flashrom_source} is not a valid flashrom source directory."
fi

if [ "${#compilers[@]}" -eq 0 ]; then
	# These are the default compilers.
	# Native and cross-builds possible on the same host, and a native build with
	# clang to check compatibility with non-gcc
	for k in "${!available_compilers[@]}" ; do
		compilers["$k"]="${available_compilers["$k"]}"
	done
fi

# get the script path
# http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in
script_path="${BASH_SOURCE[0]}"
while [ -h "$script_path" ]; do # resolve $script_path until the file is no longer a symlink
  buildbot_dir="$( cd -P "$( dirname "$script_path" )" && pwd )"
  script_path="$(readlink "$script_path")"
  # if $script_path was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  [[ $script_path != /* ]] && script_path="$buildbot_dir/$script_path"
done
buildbot_dir="$( cd -P "$( dirname "$script_path" )" && pwd )"

fill_vbox_ips

echo "buildbot_dir=${buildbot_dir}"
echo "flashrom_source=${flashrom_source}"
echo "compilers=${!compilers[@]}"
echo "flashrom_opts=${flashrom_opts[@]}"
echo "vbox_ips=${vbox_ips[@]}"
echo

PATH="${buildbot_dir}:${PATH}"
unset LANG

if [ ! -r ${www_root}/buildresults/latest-build.txt ]; then
	lastid=-1
else
	lastid=$(sed 's/.*-\(.*\)-.*/\1/' ${www_root}/buildresults/latest-build.txt)
fi
newid=$(printf "%06d" $(expr $lastid + 1))

if [ "$dryrun" -eq 1 ]; then
	echo "Simulating Build #${newid}"
	results_file=/dev/null
else
	echo "Starting Build #${newid}"
	mkdir -p "${www_root}/buildresults"
	resultdir=$(mktemp -d "${www_root}/buildresults/flashrom-${newid}-XXX")
	if [ ! -d "${resultdir}" ]; then
		msg_err "Could not create temporary directory."
	fi
	results_file="${resultdir}/results.txt"
	resultbase=$(basename "${resultdir}")
	echo -n "${resultbase}" >"${www_root}/buildresults/latest-build.txt"
	ln -s -f -T "${resultbase}" "${www_root}/buildresults/latest-build"
	if [ $priv -ne 1 ]; then
		echo -n "${resultbase}" >"${www_root}/buildresults/latest-public-build.txt"
		ln -s -f -T "${resultbase}" "${www_root}/buildresults/latest-public-build"
	fi
	echo "Build was requested in \"${flashrom_source}\"" >>"${results_file}"
	echo "for ${!compilers[@]}" >>"${results_file}"
	echo "with arguments \"${flashrom_opts[@]}\"." >>"${results_file}"
fi

# Parameter parsing and verification done.
# The real action starts below: first some helper functions to deal with managing VMs, then command abstractions to access the OS inside VMs, and finally main()

sanitize_vbox_vm () {
	vb_config=$(vboxmanage showvminfo ${1} --machinereadable | sed -ne 's/^CfgFile="\(.*\)"$/\1/p')
	chmod 660 "vb_config"
}

start_vbox_vm () {
	local ck=$1
	local vmname=${vbox_names[$ck]}
	local vmip=${vbox_ips[$ck]}

	deadline=$(date -d 3mins +%s)
	if VBoxManage list runningvms | grep -q "${vmname}" ; then
		vms_were_running[$ck]=1
		echo "${vmname} VM is already running."
	else
		VBoxHeadless --startvm "${vmname}" --vrde off >/dev/null &
	fi

	until ssh ${vm_user}@${vmip} true >/dev/null 2>&1; do
		if [ $(date +%s) -ge ${deadline} ]; then
			echo "No ssh connection within timeout, aborting"
			stop_vbox_vm $ck
			return 1
		fi
		echo "Waiting for ${vmname} VM to get reachable (for $((${deadline}-$(date +%s))) more secs)..."
		sleep 5
	done
	echo "${vmname} VM started and waiting for commands."
}

stop_vbox_vm () {
	local ck=$1
	local vm_was_running="${vms_were_running[$ck]}"
	local vmname="${vbox_names[$ck]}"
	local vmip=${vbox_ips[$ck]}
	local vmhaltcmd=${halt_cmds[$ck]}
	# default to halt -p
	if [ -z "$vmhaltcmd" ]; then
		vmhaltcmd="halt -p"
	fi
	local deadline=$(date -d 2mins +%s)
	VBoxManage list runningvms|grep -q "${vmname}" || {
		echo "${vmname} VM is already stopped. Nothing done."
		return 0
	}
	if [ -n "$vm_was_running" ] && [ "$vm_was_running" -eq 1 ]; then
		echo "${vmname} VM was not started by this build run. Leaving it alone."
		return 0
	fi

	if VBoxManage controlvm ${vmname} savestate >/dev/null 2>&1 ; then
		echo "${vmname} VM state saved successfully."
		return 0
	else
		echo "Saving ${vmname} VM state failed. Trying to shut it down instead..."
	fi
	ssh root@${vmip} ${vmhaltcmd}>/dev/null 2>&1

	while ping -c 1 ${vmip} >/dev/null 2>&1; do
		if [ $(date +%s) -ge ${deadline} ]; then
			echo "Still reachable after timeout, enforcing shutdown"
			VBoxManage controlvm ${vmname} acpipowerbutton >/dev/null
			sleep 15
			VBoxManage controlvm ${vmname} poweroff >/dev/null
			sanitize_vbox_vm ${vmname}
			return 1
		fi
		echo "Waiting for ${vmname} VM to get disconnected (for $((${deadline}-$(date +%s))) more secs)..."
		sleep 5
	done

	while VBoxManage list runningvms|grep -q "${vmname}"; do
		if [ $(date +%s) -ge ${deadline} ]; then
			echo "VM still running after timeout, aborting"
			sanitize_vbox_vm ${vmname}
			return 1
		fi
		echo "Waiting for ${vmname} VM to stop (for $((${deadline}-$(date +%s))) more secs)..."
		sleep 5
	done
	sanitize_vbox_vm ${vmname}
	echo "${vmname} VM stopped."
}

build_prepare () {
	local ck="$1"
	shift 1
	local workdir="${workdir_base}/${resultbase}/${ck}"
	
	case "$build_type" in
		vbox)
			start_vbox_vm "$ck" || return 1
			tar czf - -C "${flashrom_source}" --format=ustar . | ssh ${vm_user}@${vbox_ips[$ck]} "mkdir -p ${vm_workdir}/${resultbase}; cd ${vm_workdir}/${resultbase}; tar xzf -"
			;;
		*)
			mkdir -p "${workdir}" && cp -a "${flashrom_source}/." "${workdir}"
			;;
	esac
}

build_execute () {
	local ck="$1"
	shift 1
	local workdir="${workdir_base}/${resultbase}/${ck}"
	case "$build_type" in
		vbox)
			ssh ${vm_user}@${vbox_ips[$ck]} "cd ${vm_workdir}/${resultbase} && $@"
			;;
		*)
			cd "${workdir}" && "$@"
			;;
	esac
}

build_fetch () {
	local ck="$1"
	local dest="$2"
	shift 2
	local workdir="${workdir_base}/${resultbase}/${ck}"
	for file in "$@"; do
		case "$build_type" in
			vbox)
				scp -p "${vm_user}@${vbox_ips[$ck]}:\"${vm_workdir}/${resultbase}/${file}\"" "$dest/"
				;;
			*)
				cp -a -t "$dest" "${workdir}/${file}"
				;;
		esac
	done
}

build_destroy () {
	local ck="$1"
	shift 1
	case "$build_type" in
		vbox)
			test "$cleanup" -eq 1 && ssh ${vm_user}@${vbox_ips[$ck]} "rm -rf ${vm_workdir}/${resultbase}"
			stop_vbox_vm "$ck"
			;;
		*)
			test "$cleanup" -eq 1 && rm -rf "${workdir_base}/${resultbase}/${ck}"
			return 0
			;;
	esac
}

# set variable build_type to
#	- vbox if the compiler is hosted in a virtual box vm
#	- host if we can compile on the host machine (possibly with a cross compiler)
get_build_type () {
	if is_key_in "$1" "$(declare -p vbox_names)" ; then
		build_type="vbox"
	else
		build_type="host"
	fi
}

get_make_cmd () {
	local ck=$1
	case "$build_type" in
		vbox)
			if ssh ${vm_user}@${vbox_ips[$ck]} "command -v gmake >/dev/null 2>&1" ; then
				make_cmd=gmake
			else
				make_cmd=make
			fi
			;;
		*)
			make_cmd=make
			return 0
			;;
	esac
}

build_it () {
	local ck=$1
	local cc="${compilers[$ck]}"
	local cur_err=0
	echo "Starting $ck ($cc) build of ${flashrom_source}"
	if [ "$dryrun" -ne 1 ]; then
		local outdir="$resultdir/$ck"
		if is_key_in "$ck" "$(declare -p lib_dirs)" ; then
			local lib_option=LIBS_BASE=${libs_base}/${lib_dirs[${ck}]}
		fi
		get_build_type "$ck"
		get_make_cmd "$ck"
		mkdir "$outdir" || cur_err=1
		[ "$cur_err" -ne 1 ] && { build_prepare "$ck" || cur_err=1; }
		[ "$cur_err" -ne 1 ] && { build_execute "$ck" "$make_cmd" CC="$cc" ${lib_option} ${flashrom_opts[@]} 2>&1 | tee -a "$outdir/buildlog.txt" ;[ ${PIPESTATUS[0]} -eq 0 ] || cur_err=1; }
		[ "$cur_err" -ne 1 ] && build_fetch   "$ck" "$outdir/" flashrom.8 flashrom flashrom.exe util/ich_descriptors_tool/ich_descriptors_tool util/ich_descriptors_tool/ich_descriptors_tool.exe 2>/dev/null
		[ "$cur_err" -ne 1 ] && [ "$cleanup" -eq 1 ] && { build_execute "$ck" "$make_cmd" distclean 2>&1 | tee -a "$outdir/buildlog.txt" ;[ ${PIPESTATUS[0]} -eq 0 ] || cur_err=1; }
		build_destroy "$ck" || cur_err=1 # unconditionally clean up
	fi
	return $cur_err
}


main () {
	local errors=0
	local error_builds=()
	local -A cc_pids=()
	local make_cmd
	get_make_cmd "make_cmd"

	#############################################
	# clean up first the local source directory #
	#############################################
	test "$dryrun" -eq 1 || "$make_cmd" -C "${flashrom_source}" ${flashrom_opts[@]} distclean 2>&1

	##########################################
	# then schedule compile runs in parallel #
	##########################################
	for ck in "${!compilers[@]}"; do
		while [ $(jobs 2>&1 | grep -c Running) -ge "$j" ]; do
			sleep 1
		done
		build_it "$ck" &
		cc_pids+=(["$ck"]="$!")
	done

	######################################
	# then wait for all jobs to complete #
	######################################
	for ck in "${!compilers[@]}"; do
		pid=${cc_pids[$ck]}
		local cur_err=0
		if [ -z "$pid" ]; then
			echo "No Job ID known for the $ck process"
			cur_err=1
		else
			wait $pid
			cur_err=$?
		fi
		if [ "$cur_err" -ne 0 ]; then
			errors=$(($errors + 1))
			echo "The build with $ck (${compilers[$ck]}) above failed."
			error_builds+=("$ck")
		fi
	done

	#################################
	# cleanup and result processing #
	#################################
	echo "Done (${errors} errors)!"
	echo >>"${results_file}"
	echo "${errors} errors" >>"${results_file}"
	if [ $errors -ne 0 ]; then
		echo "The following builds failed:" | tee -a "${results_file}"
		for ck in "${error_builds[@]}"; do
			echo "$ck (${compilers[$ck]})" | tee -a "${results_file}"
		done
	fi
	test "$dryrun" -eq 1 || echo "Results in ${resultdir}"
	test "$dryrun" -eq 1 || rmdir "${workdir_base}/${resultbase}/" 2>/dev/null # not created for VM-only builds
	test "$priv" -eq 1 -o "$dryrun" -eq 1 || chmod go+rx "$resultdir"
	exit $errors
}

main
