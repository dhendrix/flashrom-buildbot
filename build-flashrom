#!/bin/bash
# TODO: Handle tarballs later.

declare -A available_compilers=([dos]=i586-pc-msdosdjgpp-gcc
				[win32]=x86_64-w64-mingw32-gcc
				[win64]=i686-w64-mingw32-gcc
				[freebsd]=x86_64-pc-freebsd9-gcc
				[gcc]=gcc
				[gcc32]="gcc -m32"
				[arm]=arm-linux-gnueabi-gcc
				[mips]=mips-linux-gcc
				[ppc]=ppc-linux-gnueabi-gcc
				[clang]=clang
				[openbsd]=i386-openbsd-gcc
				[libpayload]="CC=gcc /home/flashrom-buildbot/coreboot/payloads/libpayload/bin/lpgcc")

# checks if parameter is an element in an array. invocation example: is_in "gcc" "${available_compilers[@]}"
is_in () {
	arr=$1
	shift
	for elem in "$@"; do
		[[ "$elem" == "$arr" ]] && return 0;
	done
	return 1
}

# checks if parameter is a key in an associative array. invocation example: is_key_in "dos" "$(declare -p available_compilers)"
is_key_in () {
	key="$1"
	eval "local -A arr="${2#*=} # deserialize and eliminate old name/assignment
	test -n "${arr[$key]}"
}

# checks if parameter is element in an associative array and returns the key in the 3rd variable.
# invocation example: is_in "i586-pc-msdosdjgpp-gcc" "$(declare -p available_compilers)" "ret_val"
get_key_from_name () {
	name="$1"
	eval "local -A arr="${2#*=} # deserialize and eliminate old name/assignment
	for key in "${!arr[@]}"; do
		if [ "${arr["$key"]}" = "$name" ]; then
			eval "$3="$key""
			return 0
		fi
	done
	return 1
}

show_help() {
	echo "Usage:
${0} [-p] [-n] [-b buildbot] [-s sourcepath] [-c compiler]... [flashrom build options]

Options
    -h or --help
        Display this message.
    -n or --dry-run
        Do not create any directories or files.
    -b or --buildbot
        path to buildbot home directory
    -s or --source
        path to flashrom sources to build
    -c or --compiler
        adds a compiler to the list of compilers to use (replaces the default list, can be given multiple times)
    -p or --private
        do not make results public

    Possible compilers are: ${!available_compilers[@]}"
	exit 1
}

msg_err () {
	echo "$@ Aborting." >&2
	exit 1
}

check_arg () {
	if [ $# -ne 2 -o -z "$2" ] || [[ "$2" == -* ]]; then
		msg_err "Missing argument for $1."
	fi
}

#default values
buildbot="${BUILDBOT_HOME}"
flashrom_source=.
declare -A compilers=()
flashrom_opts=()
priv=0
dryrun=0

while [ $# -gt 0 ];
do
	case ${1} in
	-h|--help)
		show_help;
		shift;;
	-n|--dry-run)
		dryrun=1;
		shift;;
	-b|--buildbot)
		check_arg $1 "$2"
		if [ ! -d $2 ]; then
			msg_err "$2 is not a valid directory."
		fi
		buildbot="$2"
		shift 2;;
	-s|--source)
		check_arg $1 "$2"
		if [ ! -d "$2" ]; then
			msg_err "$2 is not a directory."
		fi
		flashrom_source="$2"
		shift 2;;
	-c|--compiler)
		check_arg $1 "$2"
		key_var=
		if is_key_in "$2" "$(declare -p available_compilers)" ; then
			compilers["$2"]="${available_compilers["$2"]}"
		elif get_key_from_name "$2" "$(declare -p available_compilers)" "key_var"; then
			compilers["$key_var"]="$2"
		else
			msg_err "$2 is not in the list of available compilers (nor their aliases)"
		fi
		shift 2;;
	-p|--private)
		priv=1
		shift;;
	-*)
		show_help;
		msg_err "invalid option: $1"
		;;
	*)	# everything else are flashrom build parameters
		flashrom_opts+=("$1")
		shift;;
	esac;
done

if [ -z "${buildbot}" ]; then
	msg_err "No buildbot directory given."
fi

if [ ! -d "${flashrom_source}" -o ! -e "${flashrom_source}/flashrom.c" ]; then
	msg_err "${flashrom_source} is not a valid flashrom source directory."
fi

if [ "${#compilers[@]}" -eq 0 ]; then
	# These are the default compilers.
	# Native and cross-builds possible on the same host, and a native build with
	# clang to check compatibility with non-gcc
	for k in "${!available_compilers[@]}" ; do
		compilers["$k"]="${available_compilers["$k"]}"
	done
fi

echo "buildbot=${buildbot}"
echo "flashrom_source=${flashrom_source}"
echo "compilers=${!compilers[@]}"
echo "flashrom_opts=${flashrom_opts[@]}"
echo

PATH="${buildbot}/buildbot/:${PATH}"
unset LANG

lastid=$(sed 's/.*-\(.*\)-.*/\1/' ${buildbot}/public_html/buildresults/latest-build.txt)
newid=$(printf "%06d" $(expr $lastid + 1))
if [ "$dryrun" -eq 1 ]; then
	echo "Simulating Build #${newid}"
	results_file=/dev/null
else
	echo "Starting Build #${newid}"
	resultdir=$(mktemp -d ${buildbot}/public_html/buildresults/flashrom-${newid}-XXX)
	results_file="${resultdir}/results.txt"
	echo -n $(basename ${resultdir}) >${buildbot}/public_html/buildresults/latest-build.txt
	test $priv -eq 1 || echo -n $(basename ${resultdir}) >${buildbot}/public_html/buildresults/latest-public-build.txt
	echo "Build was requested in \"${flashrom_source}\"" >>"${results_file}"
	echo "for ${!compilers[@]}" >>"${results_file}"
	echo "with arguments \"${flashrom_opts[@]}\"." >>"${results_file}"
fi
cd "${flashrom_source}"

errors=0
error_builds=()
for ck in "${!compilers[@]}"; do
	cc="${compilers[$ck]}"
	echo "Starting $ck ($cc) build in $(pwd)"
	cur_err=0
	if [ "$dryrun" -ne 1 ]; then
		outdir="$resultdir/$ck"
		mkdir "$outdir" || cur_err=1
		# We are not interested in cleanup logs for the previous run.
		gmake distclean >/dev/null 2>&1
		build-prepare "$newid" "$cc"
		build-execute "$newid" "$cc" gmake distclean 2>&1 | tee "$outdir/buildlog.txt" ;[ ${PIPESTATUS[0]} -eq 0 ] || cur_err=1
		build-execute "$newid" "$cc" gmake CC="$cc" ${flashrom_opts[@]} 2>&1 | tee -a "$outdir/buildlog.txt" ;[ ${PIPESTATUS[0]} -eq 0 ] || cur_err=1
		build-fetch "$newid" "$cc" "$outdir/" flashrom flashrom.exe util/ich_descriptors_tool/ich_descriptors_tool util/ich_descriptors_tool/ich_descriptors_tool.exe 2>/dev/null
		build-execute "$newid" "$cc" gmake distclean 2>&1 | tee -a "$outdir/buildlog.txt" ;[ ${PIPESTATUS[0]} -eq 0 ] || cur_err=1
		build-destroy "$newid" "$cc"
	fi
	if [ ${cur_err} -ne 0 ]; then
		errors=$(($errors + 1))
		echo "The build with $ck ($cc) above failed."
		error_builds+=("$ck")
	fi
done

echo "Done (${errors} errors)!"
echo >>"${results_file}"
echo "${errors} errors" >>"${results_file}"
if [ $errors -ne 0 ]; then
	echo "The following builds failed:" | tee -a "${results_file}"
	for ck in "${error_builds[@]}"; do
		echo "$ck (${compilers[$ck]})" | tee -a "${results_file}"
	done
fi
test "$dryrun" -eq 1 ||  echo "Results in ${resultdir}"
test "$priv" -eq 1 -o "$dryrun" -eq 1 || chmod go+rx "$resultdir"
exit $errors
