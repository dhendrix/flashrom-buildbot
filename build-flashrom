#!/bin/bash
# TODO: Handle tarballs later.

declare -A available_compilers=([dos]=i586-pc-msdosdjgpp-gcc
				[win32]=x86_64-w64-mingw32-gcc
				[win64]=i686-w64-mingw32-gcc
				[freebsd]=x86_64-pc-freebsd9-gcc
				[gcc]=gcc
				[gcc32]="gcc -m32"
				[arm]=arm-linux-gnueabi-gcc
				[mips]=mips-linux-gcc
				[ppc]=ppc-linux-gnueabi-gcc
				[clang]=clang
				[openbsd]=i386-openbsd-gcc
				[netbsd]=amd64-netbsd-gcc
				[dragonflybsd]=amd64-dragonflybsd-gcc
				[libpayload]="CC=/home/flashrom-buildbot/coreboot/util/crossgcc/xgcc/bin/i386-elf-gcc /home/flashrom-buildbot/coreboot/payloads/libpayload/bin/lpgcc")

declare -A vm_names=([netbsd]=NetBSD-6.1-amd64
		     [openbsd]=OpenBSD-i386
		     [dragonflybsd]=DragonFlyBSD-3.4.2-amd64)

declare -A vm_ips=([netbsd]=192.168.56.10
		   [openbsd]=192.168.56.11
		   [dragonflybsd]=192.168.56.12)

# I almost lost my insanity trying to provide a single command for this.
# NetBSD and DargonFlyBSD are missing /sbin/ in its PATH for non-login shells, but the real problem is DragonFlyBSDs
# which is just completely broken and I could not find a way to append to its PATH without breaking the other OSes.
declare -A vm_cmds=([netbsd]="/sbin/halt -p"
		    [openbsd]="halt -p"
		    [dragonflybsd]="/sbin/halt -p")

declare -A vms_were_running

# checks if parameter is an element in an array. invocation example: is_in "gcc" "${available_compilers[@]}"
is_in () {
	arr=$1
	shift
	for elem in "$@"; do
		[[ "$elem" == "$arr" ]] && return 0;
	done
	return 1
}

# checks if parameter is a key in an associative array. invocation example: is_key_in "dos" "$(declare -p available_compilers)"
is_key_in () {
	key="$1"
	eval "local -A arr="${2#*=} # deserialize and eliminate old name/assignment
	test -n "${arr[$key]}"
}

# checks if parameter is element in an associative array and returns the key in the 3rd variable.
# invocation example: is_in "i586-pc-msdosdjgpp-gcc" "$(declare -p available_compilers)" "ret_val"
get_key_from_name () {
	name="$1"
	eval "local -A arr="${2#*=} # deserialize and eliminate old name/assignment
	for key in "${!arr[@]}"; do
		if [ "${arr["$key"]}" = "$name" ]; then
			eval "$3="$key""
			return 0
		fi
	done
	return 1
}

show_help() {
	echo "Usage:
${0} [-p] [-n] [-b buildbot] [-s sourcepath] [-j numthreads] [-nc] [-c compiler]... [flashrom build options]

Options
    -h or --help
        Display this message.
    -n or --dry-run
        Do not create any directories or files.
    -b or --buildbot
        path to buildbot home directory
    -s or --source
        path to flashrom sources to build
    -c or --compiler
        adds a compiler to the list of compilers to use (replaces the default list, can be given multiple times)
    -p or --private
        do not make results public
    -j or --threads
        maximum number of concurrent build jobs
    -nc or --no-cleanup
        do not cleanup working directories

    Possible compilers are: ${!available_compilers[@]}"
	exit 1
}

msg_err () {
	echo "$@ Aborting." >&2
	exit 1
}

check_arg () {
	if [ $# -ne 2 -o -z "$2" ] || [[ "$2" == -* ]]; then
		msg_err "Missing argument for $1."
	fi
}

#default values
buildbot="${BUILDBOT_HOME}"
flashrom_source=.
declare -A compilers=()
flashrom_opts=()
priv=0
cleanup=1
dryrun=0
j=16 # default threads

# constants
workdir_base="/tmp"

while [ $# -gt 0 ];
do
	case ${1} in
	-h|--help)
		show_help;
		shift;;
	-n|--dry-run)
		dryrun=1;
		shift;;
	-b|--buildbot)
		check_arg $1 "$2"
		if [ ! -d $2 ]; then
			msg_err "$2 is not a valid directory."
		fi
		buildbot="$2"
		shift 2;;
	-s|--source)
		check_arg $1 "$2"
		if [ ! -d "$2" ]; then
			msg_err "$2 is not a directory."
		fi
		flashrom_source="$2"
		shift 2;;
	-c|--compiler)
		check_arg $1 "$2"
		key_var=
		if is_key_in "$2" "$(declare -p available_compilers)" ; then
			compilers["$2"]="${available_compilers["$2"]}"
		elif get_key_from_name "$2" "$(declare -p available_compilers)" "key_var"; then
			compilers["$key_var"]="$2"
		else
			msg_err "$2 is not in the list of available compilers (nor their aliases)"
		fi
		shift 2;;
	-p|--private)
		priv=1
		shift;;
	-nc|--no-cleanup)
		cleanup=0
		shift;;
	-j|--threads)
		check_arg $1 "$2"
		if [ "$2" -lt 1 ]; then
			msg_err "Less than 1 concurrent process is a bad idea. $2 requested."
		fi
		j="$2"
		shift 2;;
	-*)
		show_help;
		msg_err "invalid option: $1"
		;;
	*)	# everything else are flashrom build parameters
		flashrom_opts+=("$1")
		shift;;
	esac;
done

if [ -z "${buildbot}" ]; then
	msg_err "No buildbot directory given."
fi

if [ ! -d "${flashrom_source}" -o ! -e "${flashrom_source}/flashrom.c" ]; then
	msg_err "${flashrom_source} is not a valid flashrom source directory."
fi

if [ "${#compilers[@]}" -eq 0 ]; then
	# These are the default compilers.
	# Native and cross-builds possible on the same host, and a native build with
	# clang to check compatibility with non-gcc
	for k in "${!available_compilers[@]}" ; do
		compilers["$k"]="${available_compilers["$k"]}"
	done
fi

# hack for dos libraries
if is_key_in "dos" "$(declare -p compilers)"; then
	flashrom_opts+="DOSLIBS_BASE=${buildbot}"
fi

echo "buildbot=${buildbot}"
echo "flashrom_source=${flashrom_source}"
echo "compilers=${!compilers[@]}"
echo "flashrom_opts=${flashrom_opts[@]}"
echo

PATH="${buildbot}/buildbot/:${PATH}"
unset LANG

lastid=$(sed 's/.*-\(.*\)-.*/\1/' ${buildbot}/public_html/buildresults/latest-build.txt)
newid=$(printf "%06d" $(expr $lastid + 1))
if [ "$dryrun" -eq 1 ]; then
	echo "Simulating Build #${newid}"
	results_file=/dev/null
else
	echo "Starting Build #${newid}"
	resultdir=$(mktemp -d ${buildbot}/public_html/buildresults/flashrom-${newid}-XXX)
	if [ ! -d ${resultdir} ]; then
		msg_err "Could not create temporary directory."
	fi
	results_file="${resultdir}/results.txt"
	resultbase=$(basename ${resultdir})
	echo -n ${resultbase} >${buildbot}/public_html/buildresults/latest-build.txt
	ln -s -f -T "${resultbase}" "${buildbot}/public_html/buildresults/latest-build"
	if [ $priv -ne 1 ]; then
		echo -n "${resultbase}" >${buildbot}/public_html/buildresults/latest-public-build.txt
		ln -s -f -T "${resultbase}" "${buildbot}/public_html/buildresults/latest-public-build"
	fi
	echo "Build was requested in \"${flashrom_source}\"" >>"${results_file}"
	echo "for ${!compilers[@]}" >>"${results_file}"
	echo "with arguments \"${flashrom_opts[@]}\"." >>"${results_file}"
fi

# Parameter parsing and verification done.
# The real action starts below: first some helper functions to deal with managing VMs, then command abstractions to access the OS inside VMs, and finally main()

sanitize_vbox_vm () {
	chmod 660 "/home/flashrom-buildbot/VirtualBox VMs/${1}/${1}.vbox"
}

start_vbox_vm () {
	local ck=$1
	local vmname=${vm_names[$ck]}
	local vmip=${vm_ips[$ck]}

	deadline=$(date -d 3mins +%s)
	if VBoxManage list runningvms | grep -q "${vmname}" ; then
		vms_were_running[$ck]=1
		echo "${vmname} VM is already running."
	else
		VBoxHeadless --startvm "${vmname}" --vrde off >/dev/null &
	fi

	until ssh compiler@${vmip} true >/dev/null 2>&1; do
		if [ $(date +%s) -ge ${deadline} ]; then
			echo "No ssh connection within timeout, aborting"
			stop_vbox_vm $ck
			return 1
		fi
		echo "Waiting for ${vmname} VM to get reachable (for $((${deadline}-$(date +%s))) more secs)..."
		sleep 5
	done
	echo "${vmname} VM started and waiting for commands."
}

stop_vbox_vm () {
	local ck=$1
	local vm_was_running="${vms_were_running[$ck]}"
	local vmname="${vm_names[$ck]}"
	local vmip=${vm_ips[$ck]}
	local vmhaltcmd=${vm_cmds[$ck]}
	local deadline=$(date -d 2mins +%s)
	VBoxManage list runningvms|grep -q "${vmname}" || {
		echo "${vmname} VM is already stopped. Nothing done."
		return 0
	}
	if [ -n "$vm_was_running" ] && [ "$vm_was_running" -eq 1 ]; then
		echo "${vmname} VM was not started by this build run. Leaving it alone."
		return 0
	fi

	if VBoxManage controlvm ${vmname} savestate >/dev/null 2>&1 ; then
		echo "${vmname} VM state saved successfully."
		return 0
	else
		echo "Saving ${vmname} VM state failed. Trying to shut it down instead..."
	fi
	ssh root@${vmip} ${vmhaltcmd}>/dev/null 2>&1

	while ping -c 1 ${vmip} >/dev/null 2>&1; do
		if [ $(date +%s) -ge ${deadline} ]; then
			echo "Still reachable after timeout, enforcing shutdown"
			VBoxManage controlvm ${vmname} acpipowerbutton >/dev/null
			sleep 15
			VBoxManage controlvm ${vmname} poweroff >/dev/null
			sanitize_vbox_vm ${vmname}
			return 1
		fi
		echo "Waiting for ${vmname} VM to get disconnected (for $((${deadline}-$(date +%s))) more secs)..."
		sleep 5
	done

	while VBoxManage list runningvms|grep -q "${vmname}"; do
		if [ $(date +%s) -ge ${deadline} ]; then
			echo "VM still running after timeout, aborting"
			sanitize_vbox_vm ${vmname}
			return 1
		fi
		echo "Waiting for ${vmname} VM to stop (for $((${deadline}-$(date +%s))) more secs)..."
		sleep 5
	done
	sanitize_vbox_vm ${vmname}
	echo "${vmname} VM stopped."
}

build_prepare () {
	local ck="$1"
	shift 1
	local workdir="${workdir_base}/${resultbase}/${ck}"
	case "$ck" in
		openbsd | \
		netbsd | \
		dragonflybsd)
			start_vbox_vm "$ck" || return 1
			tar czf - -C "${flashrom_source}" --format=ustar . | ssh compiler@${vm_ips[$ck]} "mkdir -p ~/buildbot/${resultbase}; cd ~/buildbot/${resultbase}; tar xzf -"
			;;
		*)
			mkdir -p "${workdir}" && cp -a "${flashrom_source}/." "${workdir}"
			;;
	esac
}

build_execute () {
	local ck="$1"
	shift 1
	local workdir="${workdir_base}/${resultbase}/${ck}"
	case "$ck" in
		openbsd | \
		netbsd | \
		dragonflybsd)
			ssh compiler@${vm_ips[$ck]} "cd ~/buildbot/${resultbase} && $@"
			;;
		*)
			cd "${workdir}" && "$@"
			;;
	esac
}

build_fetch () {
	local ck="$1"
	local dest="$2"
	shift 2
	local workdir="${workdir_base}/${resultbase}/${ck}"
	for file in "$@"; do
		case "$ck" in
			openbsd | \
			netbsd | \
			dragonflybsd)
				scp -p "compiler@${vm_ips[$ck]}:\"buildbot/${resultbase}/${file}\"" "$dest/"
				;;
			*)
				cp -a -t "$dest" "${workdir}/${file}"
				;;
		esac
	done
}

build_destroy () {
	local ck="$1"
	shift 1
	local workdir="${workdir_base}/${resultbase}/${ck}"
	case "$ck" in
		openbsd | \
		netbsd | \
		dragonflybsd)
			test "$cleanup" -eq 1 && ssh compiler@${vm_ips[$ck]} "rm -rf ~/buildbot/${resultbase}"
			stop_vbox_vm "$ck"
			;;
		*)
			test "$cleanup" -eq 1 && rm -rf "${workdir}"
			return 0
			;;
	esac
}

build_it () {
	local ck=$1
	local cc="${compilers[$ck]}"
	local cur_err=0
	echo "Starting $ck ($cc) build of ${flashrom_source}"
	if [ "$dryrun" -ne 1 ]; then
		local outdir="$resultdir/$ck"
		mkdir "$outdir" || cur_err=1
		[ "$cur_err" -ne 1 ] && { build_prepare "$ck" || cur_err=1; }
		[ "$cur_err" -ne 1 ] && { build_execute "$ck" gmake CC="$cc" ${flashrom_opts[@]} 2>&1 | tee -a "$outdir/buildlog.txt" ;[ ${PIPESTATUS[0]} -eq 0 ] || cur_err=1; }
		[ "$cur_err" -ne 1 ] && build_fetch   "$ck" "$outdir/" flashrom.8 flashrom flashrom.exe util/ich_descriptors_tool/ich_descriptors_tool util/ich_descriptors_tool/ich_descriptors_tool.exe 2>/dev/null
		[ "$cur_err" -ne 1 ] && [ "$cleanup" -eq 1 ] && { build_execute "$ck" gmake distclean 2>&1 | tee -a "$outdir/buildlog.txt" ;[ ${PIPESTATUS[0]} -eq 0 ] || cur_err=1; }
		build_destroy "$ck" || cur_err=1 # unconditionally clean up
	fi
	return $cur_err
}

main () {
	local errors=0
	local error_builds=()
	local -A cc_pids=()
	# clean up first
	test "$dryrun" -eq 1 || gmake -C "${flashrom_source}" ${flashrom_opts[@]} distclean 2>&1
	for ck in "${!compilers[@]}"; do
		while [ $(jobs 2>&1 | grep -c Running) -ge "$j" ]; do
			sleep 1
		done
		build_it "$ck" &
		cc_pids+=(["$ck"]="$!")
	done

	for ck in "${!compilers[@]}"; do
		pid=${cc_pids[$ck]}
		local cur_err=0
		if [ -z "$pid" ]; then
			echo "No Job ID known for the $ck process"
			cur_err=1
		else
			wait $pid
			cur_err=$?
		fi
		if [ "$cur_err" -ne 0 ]; then
			errors=$(($errors + 1))
			echo "The build with $ck (${compilers[$ck]}) above failed."
			error_builds+=("$ck")
		fi
	done

	echo "Done (${errors} errors)!"
	echo >>"${results_file}"
	echo "${errors} errors" >>"${results_file}"
	if [ $errors -ne 0 ]; then
		echo "The following builds failed:" | tee -a "${results_file}"
		for ck in "${error_builds[@]}"; do
			echo "$ck (${compilers[$ck]})" | tee -a "${results_file}"
		done
	fi
	test "$dryrun" -eq 1 || echo "Results in ${resultdir}"
	test "$dryrun" -eq 1 || rmdir "${workdir_base}/${resultbase}/" 2>/dev/null # not created for VM-only builds
	test "$priv" -eq 1 -o "$dryrun" -eq 1 || chmod go+rx "$resultdir"
	exit $errors
}

main
